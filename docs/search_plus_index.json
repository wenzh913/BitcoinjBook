{"./":{"url":"./","title":"前言","keywords":"","body":"Bitcoinj官方文档Bitcoinj官方文档 Bitcoinj官方文档 中文版翻译. Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-27 11:38:35 "},"Bitcoinj-Basics.html":{"url":"Bitcoinj-Basics.html","title":" 限制和缺少的功能","keywords":"","body":"Basics限制和缺少的功能 介绍 错误和其他问题 安全问题 共识 隐私问题 协议遵从性 小额付款渠道 API 瘤子 理解bitcoinj安全模型 介绍 悬而未决的交易 Finney攻击 确认交易的可信度 在没有完整的块体的情况下证明包含在块中 使用bitcoinj 介绍 Futures 事件 序列化 应用程序的不同组件如何组合在一起 介绍 网络 反序列化 对等逻辑 内存池 链和存储 数据修剪 钱包 如何测试应用程序 测试网 回归测试模式 单元测试 Basics 限制和缺少的功能 介绍 bitcoinj还在开发中，缺少一些你可能认为重要的功能。它也有奇怪的怪癖和其他需要解决的问题，但是还没有人有时间去解决(总是有更重要的事情要做)。 由于项目的主要目标一直是支持SPV智能手机钱包，而将其他用例作为次要优先级，所以这些怪癖仍然存在。因此，让Android钱包表现良好，已经多次排除了其他功能和重构。 有关完整列表，请参见错误跟踪器。 下面列出了一些最重要的限制。 补丁总是受欢迎的。 错误和其他问题 电子钱包代码无法很好地扩展。 与钱包相关的所有交易都会一直加载到内存中，并在每次保存钱包时重新写入。 这导致许多应用程序都可以使用简单的磁盘格式，但是对于重度用户而言性能较差。 随着时间的流逝，我们可能会切换到日志结构的钱包文件格式来解决此问题。 安全问题 默认的硬币选择器不是很聪明，这意味着您可以通过发送很多小硬币来对您有地址的任何人进行拒绝服务攻击。 比特币将尝试使用它们来完成支出，并达到前面提到的大小/费用限制。同样，钱包只能为一个支出请求创建一个交易（就像所有其他比特币实现一样）。如果交易规模过大，除非您手动将所需的值分解，否则您将无法再创建支出。 SPV模式与完全验证是一个重要的主题，请阅读SecurityModel页面以获取有关此信息的更多信息。 对双花检测的支持不完整。 仅在某些特定情况下才处理双花。 一般支持需要升级到全球比特币协议。 BitcoinJ总是从DNS种子中引导。 它不存储或使用地址广播。 这意味着如果所有DNS种子都掉了，bitcoinj应用程序将停止运行，并且如果它们受到威胁并开始返回攻击者控制的节点，则这些应用程序将受到Sybil攻击（请参阅SecurityModel页面以获取有关此信息的更多信息。 有些特性(比如查看挂起的交易)依赖于轮询随机选择的对等点。这使得依赖未经确认的交易的用户/钱包受到了sybil攻击。在未来的版本中，我们可能会使用Tor来解决这个问题。 该代码尚未经过安全专家的专业审核，并且可能存在其他意料之外的安全漏洞（不幸的是，对于大多数与比特币相关的软件而言，这是正确的）。 该库是为不包含大量价值的移动钱包编写的，仍然是主要重点。 共识 SPV模式总是遵循工作证明最多的链。如果出现区块链的分支，少数链预计将很快消失。对于那些想要留在少数股权链上的节点，没有解决方案。 在链分割的情况下，bitcoinj不能防止少数链上的交易被重放。换句话说，bitcoinj并不能保证少数人钱包的平衡。 隐私问题 目前，布隆过滤器始终设置得非常紧。 原因是该API没有带宽模式的概念，也没有用于测量带宽使用率和调整FP速率以使其保持在范围之内的代码。 此外，构建“连贯”的过滤器链是一个具有挑战性的研究问题。 比特币P2P流量未加密（这是比特币的限制，而不是bitcoinj） 协议遵从性 完全验证模式不支持v2块格式（高度已嵌入币种交易中）。 它还可能仍然包含链拆分错误。 这是实验性的，应该这样对待。 小额付款渠道 安全问题：比特币网络允许交易延展性。 使用0.10中的代码，恶意服务器可以在广播合同tx之前对其进行修改，从而使退款无用，并导致勒索用户。 API 瘤子 Wallet类非常庞大，具有很多可以重构的功能。 在某个时候，我们可能会将其移动到单独的程序包中。 一些核心对象，如‘Block’和‘Transaction’应该是不可变的，但它们不是。 大多数核心对象都是线程安全的，但是线程安全的记录并不总是尽可能准确。 每个事件应该有一个单独的接口，但是取而代之的是有许多方法的少数几个(每个对等点一个)。这使得API难以与lambdas一起使用，比如在Java 8或Kotlin中，或者任何比Java 6更现代的语言中。在某种程度上，我们将使这些事件更加细粒度化。 有些“事件”实际上更像是自定义点(它们返回数据)，只有在SAME_THREAD执行器注册了事件监听器时才会调用它们。这是有据可查的，但有时会绊倒人。 某些配置状态在整个库中重复。0.13中引入的上下文类是解决这个问题的一个步骤。 理解bitcoinj安全模型 了解完整模式和简化模式的区别，以及如何攻击bitcoinj应用程序。 介绍 bitcoinj支持两种不同的应用模式：完全验证和简化验证。 您选择的模式控制应用程序的资源使用情况，以及您对比特币系统中其他参与者的信任程度。 作为开发人员，重要的是要了解它们之间的差异以及在什么情况下可以信任或不信任您的应用。 首先，让我们回顾一下常规完整节点的工作方式。 比特币解决的根本问题是就谁拥有什么达成共识。 每个节点都维护有一个未使用输出的数据库，而尝试使用不存在或已经使用的输出的交易将被忽略。 矿工解决区块并进行广播，以确保每个人都同意交易的顺序，因此由于某种原因（例如，它们当时处于脱机状态）而看不到广播交易的节点可以赶上。 检查，存储和更新每个交易的数据库的操作非常耗时。 从头开始追赶数据库的当前状态也非常慢。 因此，并非每台计算机都可以运行完整的节点。 bitcoinj同时实现了完整模式和“简化的付款验证”。 在这种模式下，仅存储与钱包相关的交易。 其他所有交易都会被丢弃，或者根本就不会下载。 区块链仍在使用，广播交易仍被接收，但是那些交易未被使用且无法检查以确保其有效。 这种操作模式既快速又轻巧，足以在智能手机上运行，但是可以通过多种方式击败。 悬而未决的交易 当一个交易在网络上广播时，我们说它在一个块中“待定”。挖掘节点将看到交易，自己检查它，如果它是有效的，将它包含在当前块中，它们试图解决。节点不转发无效的交易。 您的应用程序将接收挂起的交易，将它们添加到钱包中，并运行事件监听器。但是，在SPV模式中，您必须相信交易是有效的惟一原因是您连接到的转发交易的节点。如果攻击者可以确保您连接到他的节点，这将意味着他们可以向您提供完全无效的交易(已花费的不存在的钱)，并且仍然可以接受它，就好像它是有效的一样。 由于bitcoinj应用程序不接受传入连接，因此与您交谈的对等对象总是在启动时被随机选择（基于今天的DNS种子）。 因此，攻击者可能很难控制您的连接。 因此，已在TransactionConfidence对象中公开了已宣布交易的对等方的数量，您可以通过监听该消息来了解新的对等方已宣布交易的时间。 一旦大多数同行宣布，您就可以确定交易正在网络中传播，并且很有可能是有效的。 这种获得信任的方法可能受到三种攻击。 劫持您的整个Internet连接并将您连接到虚假网络。 这被称为Sybil攻击，当您使用不受信任的Internet连接（例如，咖啡店wifi）或使用Tor时，最容易中断。 Bitcoinj目前不支持Tor，因此，实际上，使用移动钱包时，这种担忧是最大的。 通过同时广播两个无效交易来利用竞争条件。 在苏黎世联邦理工学院的研究人员的论文中探索了这种技术。为了使这种技术发挥最佳效果，攻击者必须能够连接到受害者。bitcoinj应用程序不接受传入连接(他们没有理由这样做)，所以这很难实现。未来的比特币网络可能会转发双消费提醒，但目前还没有实现。 挖掘包含双倍开销的块，然后购买服务，然后广播该块。这就是所谓的 Finney attack(芬尼攻击) ，下文将对此进行讨论。 Finney攻击 在Finney攻击中，攻击者将包括他的一些硬币的花费的区块挖到了他控制的另一个地址。 一旦找到一个块，就不会立即广播它。 相反，他去了一个接受未经确认的交易并花掉硬币的商人。 一旦他从商人那里获得了他想要的商品，他就播放包含两次消费的区块，并取回硬币。芬尼的进攻依赖于精确的时机和进攻者的耐心:他必须等待，直到他找到一个区块，这可能需要很长时间。 他必须能够快速从商人那里买东西-他花在等待货物交付上的每一秒钟就是另一位矿工可能发现并播放有效区块的一秒钟，这使他的工作毫无价值。 如果满足以下条件，则可能会受到Finney攻击： 您不可逆转地出售有价值的东西，以换取未决交易 攻击者可以选择购买的时间 购买过程相对较快（不到几分钟） 以下是一些易受攻击或不易受攻击的商人的例子:： 一个自动的在线商店，出售视频游戏下载内容，并希望立即提供下载内容，而无需等待确认。 由于这是一家24/7全天候开放的在线商店，攻击者可以选择何时进行购买。 因为它是自动化的，所以购买过程很快。 因为是下载，所以除非您可以撤销某种在线许可检查，否则销售是不可逆的。 易受影响者 超级市场。 一旦您走出商店，销售是不可逆的。 但是，攻击者无法控制购买的确切时间。 除非您在网络的总采矿能力中占相当大的比例，并且每小时都在寻找区块，否则，在超级市场中扎营等待找到区块解决方案是不可行的。 即使您找到这样的街区，购买时间仍然会根据结帐柜台的排队而有所不同。 一旦发现一个区块，便很重要，等待时间越长，您越有可能使攻击失败，因此购买时间很重要。 不易受影响者 亲自进行货币交易。 发生了一笔高额的不可逆交易。 但是，同样，您通常无法立即组织和完成当面交易，这需要提前进行更多的组织。 即使您可以建议与他人见面并进行交易的时间，“购买过程”也需要很长时间。 不易受影响者 如果有人对您的应用执行Finney攻击，则该交易的TransactionConfidence可信度类型将更改为DEAD，并且会调用您注册的所有事件侦听器。 DEAD交易应被视为已撤销付款，并且不会计入您的余额。 确认交易的可信度 许多类型的应用程序不会立即提供服务，因此可以通过将其包含在区块链中来等待交易确认。 当交易包含在链中时，TransactionConfidence类型将更改为BUILDING，然后您可以深度（在此交易之上已构建了多少个区块）访问交易，并且已完成工作，这是另一个 对同一件事的看法。 例如，交易在一个区块中出现后，其深度立即为1，而完成的工作取决于当前的网络速度。 一个小时后，平均应该有6个区块，尽管实际数量相差很大。 事务置信侦听器在每次收到新的块时都会运行，因此您可以注册一个侦听器，并在达到置信度级别时使用它来触发交付商品或服务的行为。 回想一下，信心可以上升也可以下降. “重组”是指你所在的链条被一条与你的链条平行的新的最佳链条所取代。重新组织可以任意改变你的钱包，例如，通过使交易之前确认未确认或(在双消费的情况下)死亡。使交易失败的重组在Satoshis的论文中讨论过，与Finney攻击案例略有不同，后者没有重组，只有一个新的最佳块。重组很少会改变深埋在供应链中的交易信心。 仅仅因为交易出现在区块中并不意味着它是有效的。 同样，bitcoinj应用程序不会检查交易的有效性。 取而代之的是，假设很难构建一个包含无效区块的区块链，因为您必须能够超越其余所有矿工的总和。 针对这一假设，有一个漏洞尚未解决: 如果攻击者可以控制你与比特币网络的连接，他们可以阻止你看到新发现的合法块，并挖掘他们自己的包含错误交易的无效块. 这种攻击是可以检测到的，因为除非攻击者能够超越网络(51%的攻击)，否则新块到达的速度将显著下降。在未来bitcoinj可能会提供一个“红色警报”模式，其中似乎奇怪的事情被标记，它会告诉你的应用程序，是时候停止交易了。 如果你要交付高价值的东西，你需要多少信心?传统的“经验法则”是六个区块，也就是一个小时。另一种看待这个问题的方法是计算出实际上可以等待多长时间，然后查看平均在那个时间段内完成了多少工作，然后需要完成多少工作。这使得你不会随着时间的推移而对挖矿产生不同的兴趣，并确保两次攻击的成本是相同的。 在没有完整的块体的情况下证明包含在块中 要查找与您的钱包有关的交易，我们有两种选择。 我们可以下载完整的区块内容并扫描所有交易。 这是低效的-下载大量数据只是将其丢弃。 或者，我们可以从远程节点请求匹配模式的交易。 当远程节点支持它们时（v0.8及更高版本），我们将使用Bloom过滤器进行此操作。 这就带来了一个问题，即如果您没有完整的区块副本，那么如何知道接收到的交易确实出现在区块链中。 区块包含一个交易列表，一个接一个。 从该列表中，计算出Merkle tree。 该结构生成Merkle root，即单个哈希值，然后将其放入区块标题中。 这种方法比简单地对交易的连接进行散列的显而易见的方法要复杂得多，但是它具有一个主要优点：仅提供该交易和一个Merkle branch，就可以证明交易处于阻塞状态。 分支由组成原始树中同级节点的哈希组成。 如果节点将块头，交易和分支交给您，则您可以自己检查该交易确实已被网络接受，并且不太可能被伪造。 分支所占的空间比整个块体要少得多，因此这是一个主要的效率提升。 多个骄傲一可以将其合并分支合并在一起，以提高效率。 使用bitcoinj 常见的模式和你应该知道的事情。 介绍 bitcoinj在整个代码中使用了以下几个设计模式。可以在org/bitcoinj/examples和tools中查看示例代码，了解如何使用该库。 Futures 我们使用Google Guava库，尤其是ListenableFuture类。 ListenableFuture是标准JDK Future类的子类，它表示在后台进行的某些工作并产生结果。 当您发现自己有一个ListenableFuture时，可以停止并等待它完成，或者可以检查它是否已经准备就绪，或者可以等待超时，或者可以注册将被调用的回调（在某些情况下， 后台线程）完成工作时。 您可能还会在一些地方看到常规的JDK futures，随着时间的推移，这些futures将切换为ListenableFutures。 ListenableFutures有许多好处，因为添加了完成监听器，例如，它很容易做fan-in扇入和fan-out扇出等待，你也可以把futures链接在一起，所以工作是一个接一个。更多信息请参阅Guava手册。 事件 事件监听器通常在库创建的专用后台线程(称为用户线程)上异步调用。这样做有两个原因，一个是它意味着事件监听器在没有锁的情况下运行，因此没有重入限制。另一个原因是它意味着您不必编写线程安全的事件处理程序。 但是，您可以在每个侦听器级别上覆盖它，大多数方法都有一个addEventListener或addListener方法，该方法同时接受侦听器对象和一个将在其上调用它的Executor。如果您使用的框架需要线程关联性，例如GUI工具包，那么这允许您自动将回调封送到正确的UI线程中。 ListenableFuture回调也可以指定执行程序。 如果需要的话，您应该明确指定Threading.USER_THREAD。 从0.11开始，您可以将Threading.USER_THREAD执行器更改为您喜欢的任何值，这意味着您可以控制事件侦听器的执行。 当您希望将它们中继到特定线程而不是用户线程上时（例如在GUI应用程序中），这非常有用。 例如： Threading.USER_THREAD = new Executor() { @Override public void execute(Runnable runnable) { SwingUtilities.invokeLater(runnable); } }; 上面的代码片段在您的应用程序开始时运行，可确保bitcoinj回调最终在GUI线程上运行，这意味着它们可以更新小部件并以他们喜欢的任何方式更改GUI-简单！ 序列化 bitcoinj中使用了三种不同的二进制序列化格式。 有些类可以使用Java序列化进行序列化。 但是，就像Java中可序列化对象的典型做法一样，没有尝试保持长期数据兼容性。 因此，我们不建议您使用此功能，除非您要像在网络上那样临时散布数据。 Wallet类可以序列化为Google协议缓冲区格式。 这是一种可扩展的，带标签的二进制格式，很容易从多种语言中使用。 该格式由一种简单的语言描述，该语言被编译成适合您的首选环境的类。 协议缓冲区也用于小额支付协议。 最后，所有继承Message类的内容都支持专用的比特币序列化格式。 应用程序的不同组件如何组合在一起 介绍 本文向您展示典型的基于bitcoinj的应用程序中的不同对象和接口如何交互。 我们将看到数据如何从网络到达，如何转换为Java对象，然后如何遍历这些对象，直到最终将它们用于执行各种操作或保存到磁盘。 For the purposes of this article we will assume the application is a wallet. 网络 一条比特币数据的生命以两种方式开始-当它由对等网络中的另一个节点发送给我们时，或者由我们自己创建交易时。 NetworkingAPI的最低级别是实现ClientConnectionManager的对象。 该接口提供了用于打开新连接以及请求关闭某些（随机选择的）连接的方法。要打开新连接，必须提供实现StreamParser接口的对象以及要连接的网络地址。 然后，客户端连接管理器将建立一个套接字并管理对该套接字的读/写操作。 这里不能保证线程化——管理器可以在任意数量的线程上运行所提供的StreamParser方法，也可以只在一个线程上运行。提供了两个实现:BlockingClientManager和NioClientManager。 如果您创建了一个高级的PeerGroup对象，那么默认情况下将创建一个NioClientManager，不过您也可以通过构造函数提供自己的对象。它们之间的区别是NioClientManager使用单线程和基于异步epoll/select的IO，而BlockingClientManager使用标准Java阻塞套接字的每个连接使用一个线程。为什么bitcoinj支持这两种方法? 需要某些特性时，阻塞IO是很有用的。 Java可以透明地支持SSL和SOCKS代理，但仅当使用阻塞套接字时才可以。 当您要同时处理数千个连接而每个连接没有线程的额外内存压力时，异步IO很有用。 请注意，对于许多类型的应用程序，尤其是钱包或商户应用程序，您不需要大量的同时连接，因此两者之间的性能差异在很大程度上无关紧要。 同样，尽管最近每次连接线程和异步IO之间的可伸缩性差异曾经非常大，但更好的内核调度程序和多核系统的出现意味着差异不再那么明显。 仔细注意线程堆栈的大小，可能导致每个连接的线程不像以前那样昂贵。 从理论上讲，NioClientManager可以很容易地同时支持异步IO和多个线程，但是当前的实现不支持。 反序列化 如上所述，客户管理器类需要实现StreamParser接口。 该接口提供用于通知连接打开或关闭，接收原始字节缓冲区并被赋予MessageWriteTarget接口的实现的方法。 StreamParser是给定的从网络读取的数据包，不做任何帧或解析。例如，半条消息出现在StreamParser的前门上是有效的。解析器以某种方式缓冲数据、处理帧和使用数据。 当给客户端管理器一个新的解析器时，它将一个内部对象设置为MessageWriteTarget。这个接口只是公开了一个用于写入字节和关闭连接的方法。因此，解析器对象通常管理连接启动后的生命周期。 抽象的PeerSocketHandler类通过为字节流提供缓冲，校验和并将其解析为Message对象来为比特币P2P网络协议实现StreamParser。这是使用BitcoinSerializer类完成的，该类知道如何从连接中读取消息的类型及其校验和，然后构建适当的对象来表示这种消息。 它有一个从名称到对象类型的静态映射。它可以构造的每个对象都是Message类的后代。每个消息类负责从原始字节形式反序列化自己的消息。 一旦一个Message被完全构造并完成了自身的反序列化，它就会被传递给PeerSocketHandler上的一个抽象方法。因此，如果您只想访问已解析的消息流，那么此时您应该子类化。 消息的序列化是由Satoshi设计的自定义二进制格式。它的开销很小，因此灵活性也很小。 对等逻辑 但是，您的应用很可能不希望处理原始比特币协议消息流，而希望在更高级别上运行。 为此，Peer类的子类PeerSocketHandler跟踪与连接有关的状态并处理传入消息。 它提供了高级操作，例如下载块，整个链，事务，执行ping等。 它还将消息分派到与其连接的其他各种对象，特别是： 向其注册的任何PeerEventListener。 一个MemoryPool，如果提供的话（见下文）。 与之连接的所有Wallet。 提供的区块链对象（如果有）。 收到消息后，每个PeerEventListener都有机会读取和拦截消息，可能会对其进行修改，将其替换为其他消息或完全抑制进一步处理。 如果不禁止处理，则会发生以下情况： 一个接收到的“inv”消息，广告新的块或交易将导致“getdata”被发送，如果Peer已被指示下载数据。MemoryPool将被通知“inv”。 接收到的包含交易数据的“tx”消息首先通过MemoryPool传递。然后，通过isPendingTransactionRelevant询问每个Wallet是否关心特定的交易，以及是否处理所有挂起的交易依赖项也会递归下载。完成递归下载后，交易和所有挂起的依赖项将被传递到Wallet.receivePending()。最后调用PeerEventListener.onTransaction。 接收到的块、过滤的块或块头被发送到AbstractBlockChain对象进行进一步处理。 如果一个远程对等端使用“getdata”请求我们的交易数据，则对钱包和侦听器进行轮询，以查看是否有任何一个能提供该数据，如果有，则发送响应。 诸如ping或警报之类的杂项消息会在适当的时候处理。 内存池 知道有多少个对等方（和哪个对等方）宣布了特定交易可能很方便。 请参阅关于bitcoinj SecurityModel的文章，以获取有关为何可能如此有趣的信息。 为了实现这一点，MemoryPool类跟踪已看到的交易和事务哈希。 例如，如果一个对等方向我们发送一个“ inv”，它带有哈希值\"87c79f8d77fe2078333c612e2bdf1735127c6c02\"的交易，则Peer将通知MemoryPool，并记录该对等方已看到该交易。 我们最终可能会下载给定的交易，以了解它是否属于我们，这时还将交易交给MemoryPool，以防万一应用的某些部分对其感兴趣。 随着更多inv的到来，交易可信度对象也会更新。 相同的“ tx”消息可能多次发送给我们。 通常这是不应该发生的。 但是，如果这样做，MemoryPool会对它们进行重复数据删除以确保只有一个Java对象是浮动的，即使它多次反序列化也是如此。 链和存储 AbstractBlockChain的子类负责接收块，将块装配在一起并对其进行验证。 顾名思义，BlockChain类执行SPV级别验证，FullPrunedBlockChain执行完整验证。 您将区块链传递给Peer或PeerGroup，并且区块数据通过该连接从网络，区块链对象流向BlockStore接口的实现。 有多种类型的块存储，但是所有块存储都采用块数据并至少保存标头，并可能（对于完整存储）也存储交易数据。 对于SPV客户端，通常选择SPVBlockStore，对于全模式客户端，则需要FullPrunedBlockStore的实现，例如，H2FullPrunedBlockStore。 stores直接与数据库或磁盘文件对话。 它们下面没有其他对象。 链在其BlockChainListener上调用回调。 Wallet是区块链侦听器的一个示例，尽管建议使用更具体的BlockChain.addWallet()方法（它的作用与addListener()相同，但将来可能会改变）。 针对以下事件调用侦听器： notifyNewBestBlock: 当发现扩展了最知名链的新块时调用。这是系统的正常延续。 block参数仅是一个块头-没有可用的交易数据。 reorganize: 当接收到一个扩展侧链并使其成为新的最佳链的区块时调用。 重新组织会导致一个时间轴被另一条时间轴代替，在另一条时间轴中可能已重新排序，替换或完全取消了交易。 因此，听众在听到有关重组的信息时，必须更新其内部簿记以应对新情况。 重组方法的区块链段已更改，因此他们可以弄清楚该怎么做。 如果您正在实现自己的侦听器，可能会很想跳过此步骤，并且您的应用程序似乎可以运行，但是忽略重组将使您的应用程序遭受安全攻击和数据损坏。 isTransactionRelevant: 调用块中的每个交易，以确定侦听器是否对其感兴趣。 这是一个优化步骤，以后可能会删除-允许区块链避免在SPV模式下具有完整（未过滤）区块时验证merkle树，除非该区块中存在与我们钱包相关的实际交易 （向/从我们的钥匙寄钱）。 这在手机上有很大的不同，但是随着布隆过滤的推出，它将变得越来越有用。 receiveFromBlock: 当接收到包含它的块时，调用前一个方法认为相关的每个交易。块可能在最好的链上，也可能不在最好的链上，参数告诉你它是哪一个。请注意，当Bloom filter处于活动状态时，并不是所有的交易都显示在这里——如果交易之前是由节点发送给我们的，那么当包含它的块被解决时，节点就不会再发送它了，我们只会收到散列。这是为了节省带宽。因此，还有一个…… notifyTransactionIsInBlock: 这和receiveFromBlock一样，但是为您提供的是散列而不是完整的交易。 此时，侦听器应已具有交易数据的副本。 按顺序，最佳链上的一个新的完整块为每个交易触发isTransactionRelevant，receiveFromBlock，然后notifyNewBestBlock。一个新的过滤块在最佳链触发isTransactionRelevant，混合使用receiveFromBlock或notifyTransactionIsInBlock，然后是notifyNewBestBlock。扩展侧链的新块具有相同的序列，但没有notifyNewBestBlock，而扩展侧链并导致重新组织的新块具有相同的序列，但在末尾调用reorganize而不是notifyNewBestBlock。 对于SPV模式的应用程序，将为块存储提供所有非孤立块（无论它们在何处连接），并且当新的最佳链头发生变化时将被通知，以便将其写入磁盘。它只被期望存储标题。 数据修剪 对于一个完整的验证节点，存储需要做更多的工作，并且必须实现“FullPrunedBlockStore”接口。链和存储一起实现了ultraprune(超级运行)算法，就像比特币0.8+一样。 但是，与Bitcoin 0.8不同，该存储实际上会在一段时间后永久删除不需要的数据，因此它无法将链服务到其他节点，但是占用的磁盘空间要低得多。 修剪节点不会尝试存储整个块链。 相反，它仅存储未使用的交易输出集（UTXO集）。 一旦花费了交易输出，就不再需要其数据，可以将其删除。 重新组织事件在某种程度上使情况变得复杂，因为它们可以重写历史，因此修剪存储也应该保留一些“undo blocks(撤消块)”，这些“撤消块”允许对UTXO集的更改进行逆转。 存储的撤消块的数量是所使用的磁盘空间和可处理的最大重组之间的权衡。如果撤销块被丢弃得过于频繁，大型重组可能会永久性地将节点踢出链，迫使从头开始重新初始化，所以最好保持保守。 FullPrunedBlockStore接口提供了添加、删除和测试UTXO集的方法。它还提供了插入块和撤消块以及开始/结束数据库事务的方法(注意:与比特币事务不同)。 钱包 Wallet类充当块链侦听器，并从链对象接收数据和事件。 它会将接收到的数据保存在自己的内部，并跟踪钱包用户可能感兴趣的所有交易，例如将钱转入其密钥的交易。 可以使用WalletProtobufSerializer将钱包保存到协议缓冲区中，并且提供了在钱包发生变化时自动保存钱包的功能。 目前，钱包无法将自己存储到数据库中。这将是未来的一个很好的补充。 钱包还负责更新其中的交易的信任级别。 钱包外的交易可能会在新的同行宣布时由MemoryPool更新，但最终不会了解其在链中的位置。 如何测试应用程序 对于任何使用金钱的软件来说，测试显然是重要的一步。 本文介绍了一些用于测试比特币应用程序的常用技术。 测试网 比特币社区运行着一个单独的，并行的比特币网络实例，该实例具有一个稍微不同且更为宽松的规则集，称为testnet。 最有用的是，测试网上的硬币没有价值，可以从诸如https://testnet-faucet.mempool.co/或http://tpfaucet.appspot.com/之类的测试网水龙头站点免费获得。 您可以通过使用TestNetParams.get()而不是MainNetParams.get()实例化对象来使您的应用使用测试网。 钱包工具应用程序也接受标志--net=TEST。 值得注意的是，尽管testnet可以方便使用，但有时人们会通过使用ASIC对其进行挖掘来弄乱它。 此类问题在主网络上不会发生，因此，如果您发现相隔几秒钟发现大量突发块，未通过验证的块等，则值得改用本地回归测试网络：环境要受控制得多，并且 可预测。 回归测试模式 testnet目前为止还不错，但是仍然存在每十分钟就会挖掘一个块的问题。通常你不想等待一个新的街区，你不想使用水龙头网站来获得测试硬币。 为简化起见，从Bitcoin Core 0.9开始，有一种称为regtest模式的新模式。 您可以像这样在regtest模式下运行本地比特币： ./bitcoind -regtest 运行之后，您可以在另一个窗口中执行以下操作 ./bitcoin-cli -regtest generate 101 …按需创建一个新块。 Regtest模式需要使用另一组网络参数RegTestParams.get()，并且只能在本地运行。 没有公共的regtest网络。 您可以使用PeerGroup.connectToLocalHost()使其与本地bitcoind对话。 请注意，新开采的硬币必须成熟（这是通用的比特币规则）。 这意味着它们不会成为可支配的100个块。 上面命令中的数字101选择要挖掘的块数。 因此，这应该给您可花费的硬币。 然后，您可以像这样将一些测试硬币发送到您的应用程序： ./bitcoin-cli -regtest sendtoaddress 10.0 ./bitcoin-cli -regtest generate 1 块链等存储在~/.bitcoin/regtest中，因此您可以将其删除以重新开始，或使用-datadir来将文件保存在其他位置。 您可以使用--net=REGTEST --peers=localhost使wallet-tool使用此模式。 目前，bitcoinj还没有一个包装Bitcoin Core RPC接口和驱动regtest模式的类，但是将来会是一个不错的功能。 单元测试 Bitcoinj提供了一个TestUtils类，该类可以做一些伪造的Transaction对象之类的事情。 查看bitcoinj本身的测试套件，以了解如何使用实用程序。 单元测试是增强软件健壮性的一种好方法，尽管由于比特币协议的许多细微复杂性，它们并不总是足以确保一切正常。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-12-03 15:51:36 "}}